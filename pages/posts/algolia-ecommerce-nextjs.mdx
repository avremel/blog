import { Aside, BlogMarkdown, Image } from '../../components'

export const meta = {
  title: 'Algolia ü§ù Ecommerce ü§ù NextJS',
}

# Algolia ü§ù Ecommerce ü§ù NextJS

A collection of notes/impressions/footguns.

### Search

First you need to decide which attributes get searched and in which order ("Searcheable attributes"). A typical example might be:
1. Brand
2. SKU
3. Type, Appearance
4. Color

The default ranking mechanism is:
- `typo`: Results with more typos are demoted.
- `words`: Number of words from the query that matched at least once.
- `filters`: Score of filters when using filters or Rule boosts.
- `exact`: Number of query words matching exactly.

You can layer on custom signals to further influence the order of results ("Ranking and Sorting"), in two flavors:
1. Custom rankings (relative boosts like Solr's [`bq` parameter](https://solr.apache.org/guide/7_6/the-dismax-query-parser.html)). Useful for boosting in stock, popular, new products, etc.
2. Strict sort. Generally, I would avoid strict sort, as it overrides the default of sort-by-relevance. I did find it helpful if you are [rolling up variants](https://www.algolia.com/doc/guides/managing-results/refine-results/grouping/how-to/item-variations/) into a single product card and want to control which variant shows up first. 

Debugging search relevance is intuitive and painless, thanks the Ranking popup in the dashboard which explains why a specific record ranks the way it does relative to other records.

<Image src="/debug_relevance.png" alt="Debugging relevance in Algolia's dashboard" />

Algolia's approach to configuring and tweaking search relevance feels like it's at the right layer of abstraction. Simple to understand, sensible defaults, yet customizable. Contrast with Solr, which requires the user to fiddle with low level primitives like tokenizers, ngrams and pesky math. Debuggin search relevance in Solr requires the users to have intimate knowledge of _how_ Solr determines relevance.

For Lucene based search engines, see [Relevant Search](https://www.manning.com/books/relevant-search) and my [toy search engine](https://github.com/avremel/lucene).

### Filtering

Any attribute that will be used as a filter needs to be added to the Facets list. Filters come with counts and are searchable.

<Image className="algolia-facet" src="/facet.png" alt="Brand filter example" />

If you have chosen to [roll up variants](https://www.algolia.com/doc/guides/managing-results/refine-results/grouping/how-to/item-variations/), there are a number of approaches to Filtering:
1. Have all filters reflect variant counts. This is the default behavior.
2. Set `facetingAfterDistinct` globally [docs](https://www.algolia.com/doc/api-reference/api-parameters/facetingAfterDistinct/), to only show and count filter values which are part of the primary variant.
3. Apply `afterDistinct` [docs](https://www.algolia.com/doc/api-reference/api-parameters/attributesForFaceting/#parameter-option-afterdistinct) to individual filters. Only those filters will reflect the primary variant.

Algolia has a [widget](https://www.algolia.com/doc/api-reference/widgets/numeric-menu/react-hooks/) to display preset ranges. The problem is that a) it's single select, b) doesn't show counts and c) will show options that lead to zero results. The recommended workaround is to create a new attribute at index time to bucket the filter values and display a regular facet.

### Sorting
Each sort requires a new index which is kinda painful to manage. The recommended approach is to use [virtual replica](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/in-depth/replicas/#what-are-virtual-replicas)'s.

Beware that merchandising rules get copied over when sort indices are created and can potentially interfere with sorting.

### Merchandising

Rule's have a rich set of features. Rules can be triggered by search term, filter or context (a user defined tag, for example mobile/desktop). It can also be limited by a date range - useful for promotions.

A rule can have mulitple "strategies":
- Pin/hide products
- Boost/bury by any filterable attribute (category, brand, style, etc).
- Filter results
- Redirect

What I described is a visual rule. Confusingly there is another type of rule ("manual rule") with some overlapping functionality but also has different features. A manual rule can:
- Be triggered by detecting a facet value in a query [docs](https://www.algolia.com/doc/guides/solutions/ecommerce/filtering-and-navigation/tutorials/auto-selected-facets/)
- Dynamically add query parameters
- Remove/replace words
- Replace an entire query
- Create a conditionless rule [docs](https://www.algolia.com/doc/guides/managing-results/rules/rules-overview/?utm_medium=page_link&utm_source=dashboard#conditionless-rules)

Visual and manual rules cannot coexist with the same triggers (the first rule [takes precedence](https://www.algolia.com/doc/guides/managing-results/rules/rules-overview/in-depth/rule-matching-algorithm/#precedence-logic)).

Pinning with filters gets orphaned items.

Can merchandise query suggestions index

frontend - only include instantsearch + hooks with autocomplete on the list page!! otherwise will make network calls on every single page load!!!

export default ({ children }) => <BlogMarkdown meta={meta}>{children}</BlogMarkdown>