import { BlogMarkdown, Image } from '../../components'

export const meta = {
  title: 'Algolia + Ecommerce + NextJS',
}

# Algolia + Ecommerce + NextJS

### Item Variants

<div>
  <div>Many ecommerce sites will have a product card which displays variantions of an item like color and size.</div>

  <img className="algolia-variants" src="/variants.png" alt="T-shirts with color variants" />
</div>

<br style={{ clear: 'left' }} />

To setup, you will [need to](https://www.algolia.com/doc/guides/managing-results/refine-results/grouping/how-to/item-variations/):

- Create a record for each variant.
- Turn on Distinct (`distinct`) and choose an attibute to group variants (`attributeForDistinct`).
- To display meaningful information for each variant - like price and an image - you will need to duplicate the data so that each variant record contains data for _every_ one of it's siblings.
- To control which variant shows up as the primary record, add a strict sort to Ranking and Sorting (SORT BY `is_default_varaint`).

Your data will look like something like:
```json
[
  {
    "is_default": true,
    "group_sku": "AB",
    "sku": "AB1",
    "color": "blue",
    "variants": [
      { "sku": "AB1", "color": "blue", "price": 100 },
      { "sku": "AB2", "color": "yellow", "price": 100 },
    ]
  },
  {
    "is_default": false,
    "group_sku": "AB",
    "sku": "AB2",
    "color": "yellow",
    "variants": [
      { "sku": "AB1", "color": "blue", "price": 100 },
      { "sku": "AB2", "color": "yellow", "price": 100 },
    ]
  }
]
```

ðŸ”¸ Filtering won't remove irrelevant variants from a recored. For example, if you filter by blue, the other colors will still show up. You'll need to remove them with application code.

### Search

You choose which attributes get searched and in which order ("Searcheable attributes"). A typical example might be:
1. Brand
2. SKU
3. Type, Appearance
4. Color

The default ranking mechanism is roughly:
- `typo`: Results with more typos are demoted.
- `words`: Number of words in the query which match at least once.
- `filters`: Score of filters when using filters or Rule boosts.
- `exact`: Number of query words matching exactly.

You can layer on custom signals to further influence the order of results ("Ranking and Sorting"), in two flavors:
1. Custom rankings (relative boosts like Solr's [`bq` parameter](https://solr.apache.org/guide/7_6/the-dismax-query-parser.html)). Useful for boosting in stock, popular, new products, etc.
2. Strict sort. Generally you want to avoid strict sort, as it overrides sort-by-relevance. One exception is if you are rolling up variants and would like to control which variant is the primary one. 

Debugging search relevance is intuitive and painless, thanks the ranking popup in the dashboard which explains why a specific record ranks the way it does relative to other records.

<Image src="/debug_relevance.png" alt="Debugging relevance in Algolia's dashboard" />

Algolia's approach to configuring and tweaking search relevance feels like it's at the right layer of abstraction. Simple to understand, sensible defaults, yet customizable. Contrast with Solr/Elastic Search, which requires the user to fiddle with low level primitives like tokenizers, ngrams and pesky math.

<aside style={{ background: '#1D1F200D', padding: '10px' }}>
  To understand the mechanics of Lucene based search engines, see <a target="_blank" href="https://www.manning.com/books/relevant-search">Relevant Search</a> and my <a target="_blank" href="https://github.com/avremel/lucene">demo search engine</a>.
</aside>

### Filtering

<div>
  <div>Any attribute that will be used as a filter needs to be added to the Facets list. Filters come with counts and are searchable.</div>

  <img className="algolia-facet" src="/facet.png" alt="Brand filter example" style={{ marginLeft: '10px', float: 'right' }} />
</div>

If you have chosen to [roll up variants](https://www.algolia.com/doc/guides/managing-results/refine-results/grouping/how-to/item-variations/), your options are:
1. The default behavior of having all filters reflect variant counts.
    -  âš  Users will see inflated counts in filters which won't reflect the number of items on the page.
2. Set `facetingAfterDistinct` globally ([docs](https://www.algolia.com/doc/api-reference/api-parameters/facetingAfterDistinct/)) to only show and count filter values which are part of the primary variant.
    -  âš  Values which don't show up as a primary variant for a given set of results will be ignored.
3. Apply `afterDistinct` ([docs](https://www.algolia.com/doc/api-reference/api-parameters/attributesForFaceting/#parameter-option-afterdistinct)) to individual filters. Only those filters will reflect the primary variant.

âš  Algolia has a [widget](https://www.algolia.com/doc/api-reference/widgets/numeric-menu/react-hooks/) to display preset ranges. The problem is that a) it's single select, b) doesn't show counts and c) will show options that lead to zero results. The recommended workaround is to create a new attribute at index time to bucket the filter values and display a regular facet.

### Sorting
Each sort requires a new ([virtual](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/in-depth/replicas/#what-are-virtual-replicas)) index. For example, you need an index for price ascending _and_ price descending.

ðŸ”¸ Merchandising rules (and other settings) get copied over to new sort indices and can potentially interfere with sorting. Make sure to remove them as needed.

### Merchandising

#### Rules

Merchandising rules come with a rich set of features. Rules can be triggered by a search term, filter or a context (for example mobile/desktop). It can also be limited by a date range which is useful for seasonal promotions.

Conveniently, the query suggestion index can be merchandised as well.

A rule can have multiple consequences:
- Pin/hide products
- Boost/bury by any filterable attribute (category, brand, style, etc).
- Filter results
- Redirect
- Control which filters should display
- Control how filter values should display (pin, sort, etc)

Keep in mind that:
1. Rules have no notion of hierarchy. A sub-category will not inherit from a rule from its parent category.
2. Only one rule will match at a time. You can't have one rule control pinnning and another control boosting. [Rule precedence logic](https://www.algolia.com/doc/guides/managing-results/rules/rules-overview/in-depth/rule-matching-algorithm/#precedence-logic) arbitrates which rule gets actived.

Because of these contraints, if you have a general rule (for example, `in_stock = true`) with a bunch of consequences and a more specific rule (for example, `in_stock = true AND color = 'green`) with an additional consequence, you will need to copy over the consequences from the general rule to the more specific rule.

I prefer to not use rules for configuring filter display logic. Filter display is rarely modified and is no big deal to roll-your-own.

ðŸ”¸ In some scenarios, you will need to actively monitor pinned items: If you have a filter trigger (for example, `in_stock = true`) which pins 10 items to the top of a list and some items go out of stock, their positions will become "orphaned" and be filled by random items. There is no automatic way to keep all the pinned items at the top of the list. 

#### Manual Rules

The previous section described "visual" rules.

Confusingly there is another type of rule - "manual rule" - with some overlapping functionality but also different features. A manual rule can:
- Be triggered by detecting a facet value in a query ([docs](https://www.algolia.com/doc/guides/solutions/ecommerce/filtering-and-navigation/tutorials/auto-selected-facets/))
- Dynamically add query parameters
- Remove/replace words
- Replace an entire query
- Create a conditionless rule ([docs](https://www.algolia.com/doc/guides/managing-results/rules/rules-overview/?utm_medium=page_link&utm_source=dashboard#conditionless-rules))

ðŸ”¸ Visual and manual rules cannot coexist for the same triggers, so you will have to choose one or the other.

### Analytics

Algolia provides a ton of data about how a user interacts with search:
- Which categeries were visited
- Which filters were clicked on
- Top search terms
- Searches without clicks
- Searches without results
- Click through rate
- Conversion rate

ðŸ”¸ Conversions don't diffrentiate between add-to-cart and a purchase. Ideally, they would be separate events. 

You can further enrich the data by providing custom `analyticsTags` ([docs](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/)). For example:
  - Tag which queries are coming from autocomplete or from the list page.
  - Tag queries by category page.
  - A/B test a new user experience.

Provides for providing insight into how users are engaging with your website, Algolia uses these signals for [dynamic reranking](https://www.algolia.com/doc/guides/algolia-ai/re-ranking/), [personalization](https://www.algolia.com/doc/guides/personalization/what-is-personalization/) and [Recommend](https://www.algolia.com/doc/guides/algolia-recommend/overview/).

### Frontend Library

#### Why use an official client

<aside style={{ background: '#1D1F200D', padding: '10px' }}>
  The Search REST API is the core of Algolia Search. Around it, Algolia built a complete ecosystem, of libraries, tools, and a dashboard. You should use the official API clients and libraries to implement Algolia. They're all open source, and the code is available on GitHub.
</aside>

<aside style={{ background: '#1D1F200D', padding: '10px', marginTop: '10px' }}>
  There's no SLA if you use the REST API directly.
</aside>

Quotes from [here](https://www.algolia.com/doc/rest-api/search/).

The offical clients come with per-session in-memory [caching](https://www.algolia.com/doc/api-client/getting-started/customize/javascript/?client=javascript#caching-requests-and-responses), network retries for flakey connections and much more.

ðŸ’¡ You may be tempted to call the API's directly to cache responses and save on usage costs. However, besides for losing out on the many other benefits, you miss out on analytics, which are an important component of the product.

#### Libraries

JS libraries:
- [Autocomplete](https://www.npmjs.com/package/@algolia/autocomplete-js)
- [InstantSearch](https://www.npmjs.com/package/instantsearch.js)
- [Search Insights](https://www.npmjs.com/package/search-insights)

For NextJS/React:
- [react-instantsearch](https://www.npmjs.com/package/react-instantsearch)
- [react-instantsearch-router-nextjs](https://www.npmjs.com/package/react-instantsearch-router-nextjs)

The key to understanding Instant Search is that the state of the app is derived from widgets that are mounted to the DOM. More specifically, when the filters are on the page and you make a selection, that selection is reflected in the URL and the filter badges. If you remove the filters, the selection is cleared.

The common advice is to hide filters with CSS as needed. See [here](https://support.algolia.com/hc/en-us/articles/14677269895569-How-can-I-hide-my-filters-without-losing-the-applied-refinements-) and [here](https://discourse.algolia.com/t/instantsearch-js-3-how-to-dynamically-hide-show-a-filter-widget/10944) and a [React flavor](https://www.algolia.com/doc/guides/building-search-ui/widgets/show-and-hide-widgets/react/#keep-the-widget-mounted-but-hidden) of the same advice.

One consequence of this architecture is that you cannot use UI libraries that remove elements from the DOM. For example, you cannot use Algolia hooks inside Radix UI's [dialog component](https://www.radix-ui.com/primitives/docs/components/dialog).

Another consequence is that in order to get server-side-rendering (SSR) working for NextJS, you need to:
1. Extract the Algolia state by calling [getServerState](https://www.algolia.com/doc/api-reference/widgets/server-state/react/) with your _entire app_.
2. Feed the Algolia state to `InstantSearchSSRProvider`.

ðŸ”¸ Since you are running your app server side solely to get back the Algolia state, you only care about mounting Algolia hooks and can avoid rendering anything else.

### Usages

debounce autocomplete

### Frontend

what is autocomplete

- only include instantsearch + hooks with autocomplete on the list page!! otherwise will make network calls on every single page load!!!
  - conditional hooks by wrapping... but can get _very_ messy
- single hook per filter
- never duplicate hooks
- dont remove or add widgets (like filters) after the initial load, hide with css  if needed
getServerState widgets/facets should match the app to avoid dupe calls
- cant use next/router (router.push/Link) if server side props change which trigger change in hooks

### security

export default ({ children }) => <BlogMarkdown meta={meta}>{children}</BlogMarkdown>