import { Aside, BlogMarkdown } from '../../components'

export const meta = {
  title: '100 Code Challenges',
}

# 100 Code Challenges

<Aside pTags={
  [
    `Gotta hold myself accountable. Mostly Interview Camp related.`,
  ]} />

## 13. Find Peak

Interview Camp Ch 5. Homework #3.

<Aside pTags={[
  `Search for a Peak: A peak element in array A is an A[i] where its adjacent elements are less than A[i]. So, A[i - 1] < A[i] and A[i + 1] < A[i].`,
  `Assume there are no duplicates. Also, assume that A[-1] and A[length] are negative infinity (-âˆž). So A[0] can be a peak if A[1] < A[0].`
]} />

```js
const findPeak = arr => {
  let start = 0
  let end = arr.length-1

  while (start <= end) {
    let mid = Math.floor(start + (end-start) / 2)

    // peak at ends
    if ((mid === 0 && arr[mid] > arr[mid+1]) || (mid === arr.length-1 && arr[mid] > arr[mid-1])) {
      return arr[mid]
    }

    // peak in middle
    if (arr[mid] > arr[mid-1] && arr[mid] > arr[mid+1]) {
      return arr[mid]
    }

    if (arr[mid] > arr[mid-1]) {
      start = mid+1
    } else {
      end = mid-1
    }
  }
}

```

## 12. squareRoot

Interview Camp Ch 5. Homework #2.

<Aside pTags={[
  `Find the square root of an integer X. For example, squareRoot(4) = 2. It is ok to find the integer floor of the square root. So squareRoot(5) or squareRoot(8) can also return 2. squareRoot(9) will return 3.`,
  `Using Binary Search, you can search for square roots over the integer space. This is pretty fast because it takes O(log(n)) time. Assume that x*x is less than the integer limit.`,
]} />

```js
// closer but lower
const isCloser = (n, closest, cur_closest) => {
  const newTotal = cur_closest ** 2
  const oldTotal = closest ** 2

  if (newTotal >= n) return false

  return (newTotal > oldTotal) && newTotal < n
}

const squareRoot = n => {
  let start = 1
  let end = n
  let closest = start

  while (start <= end) {
    let mid = Math.floor(start + (end-start) / 2)
    let result = mid ** 2
    
    if (result === n) return mid

    if (isCloser(n, closest, mid)) {
      closest = mid
    }

    if (result > n) {
      end = mid-1
    } else {
      start = mid+1
    }
  }

  return closest
}

```

## 11. Binary insert at index

Interview Camp Ch 5. Homework #1.

<Aside pTags={[
  `You are given a sorted array A and a target T. Return the index where T would be placed if inserted in order. For example,`,
  `A = [1,2,4,5,6,8] and T = 3, return index 2`,
  `A = [1,2,4,5,6,8] and T = 0, return index 0`,
  `A = [1,2,4,5,6,8] and T = 4, return index 3.`,
]} />

```js
const binaryInsert = (arr, num) => {
  if (!arr) return null
  if (!arr.length) return 0

  let start = 0
  let end = arr.length-1

  while (start <= end) {
    let mid = Math.floor(start + (end-start) / 2)

    if (arr[mid] > num) {
      if (mid-1 < 0 || arr[mid-1] <= num) {
        return mid
      }
      end = mid-1
    } else {
      start = mid+1
    }
  }

  return arr.length
}
```

## 10. Find first occurrence

Interview Camp Ch 5. Lecture #1.

<Aside pTags={[
  `Given a sorted array that can contain duplicates, find the first occurrence of a target element T.`,
  `For example, if A = [2,3,4,4,5,6] and T = 4, return index 2.`,
]} />

```js
const binaryFindFirst = (arr, target) => {
  let start = 0
  let end = arr.length-1

  while (start <= end) {
    let mid = Math.floor(start + (end-start)/2)

    if (arr[mid] > target) {
      end = mid-1
    } else if (arr[mid] < target) {
      start = mid+1
    } else {
      const prevIdx = mid-1
      if (prevIdx < 0 || arr[prevIdx] !== target) {
        return mid
      }
      end = mid-1
    }
  }

  return -1
}
```

## 9. Prefix sum with target

Interview Camp Ch 2. Homework #2

<Aside pTags={[
  `Given an array of positive and negative integers, find a subarray whose sum equals X.`,
  `For example: Input = [2,4,-2,1,-3,5,-3], X = 5 --> Result = [2,4,-2,1]`,
]} />

```js
const prefixSumWithTarget = (arr, target) => {
  if (!arr || !arr.length) return null

  let idx_by_sum = {}
  let sum = 0

  for (let i=0; i<arr.length; i++) {
    sum += arr[i]

    if (sum === target) {
      return [0, i]
    }

    const matchingSum = idx_by_sum[sum-target]

    if (matchingSum !== undefined) {
      return [matchingSum + 1, i]
    }

    idx_by_sum[sum] = i
  }

  return null
}
```

## 8. Longest Unique Substring

Interview Camp Ch 2. Homework #1

<Aside pTags={[
  `Given a String, find the longest substring with unique characters.`,
  `For example: "whatwhywhere" --> "atwhy"`,
]} />

```
const longestSubstring = str => {
  let start = end = 0
  let longestNumChars = 0;
  let longest = null;
  let currSet = new Set()

  while (start < str.length) {
    if (currSet.has(str[end])) {
      const numChars = end - start
      if (numChars > longestNumChars) {
        longestNumChars = numChars
        longest = str.slice(start, end)
      }

      currSet.delete(str[start])
      start++
    } else {
      currSet.add(str[end])
      end++
    }
  }

  return longest
}
```

## 7. Sort Marbles

Interview Camp Ch 1. Homework #4

<Aside pTags={[
  `Given an array with n marbles colored Red, White or Blue, sort them so that marbles of the same color are adjacent, with the colors in the order Red, White and Blue.`,
  `Assume the colors are given as numbers - 0 (Red), 1 (White) and 2 (Blue).`,
  `For example, if A = [1,0,1,2,1,0,1,2], Output = [0,0,1,1,1,1,2,2].`,
]} />

```js
const swap = (arr, a, b) => {
  const aVal = arr[a]
  const bVal = arr[b]

  arr[b] = aVal
  arr[a] = bVal
}

const sortMarbles = (arr, pivot) => {
  let leftBound = 0
  let rightBound = arr.length - 1

  for (let i=0; i<arr.length-1; i++) {
    if (arr[i] < pivot) {
      swap(arr, i, leftBound)
      leftBound++
    }
  }

  for (let i=arr.length-1; i>=0; i--) {
    if (arr[i] > pivot) {
      swap(arr, i, rightBound)
      rightBound--
    }
  }


  return arr
}
```

## 6. Sub array to sort

Interview Camp Ch 1. Homework #3

<Aside pTags={[
  `Given an array of integers, find the continuous subarray, which when sorted, results in the entire array being sorted.`,
  `For example: A = [0,2,3,1,8,6,9], result is the subarray [2,3,1,8,6]`,
]} />

```js
const subArrayUnsorted = arr => {
  let start_unsorted = null
  let end_unsorted = null

  // asc look for dip
  for (let i=0; i<arr.length - 1; i++) {
    if (arr[i] > arr[i+1]) {
      start_unsorted = i
      break
    }
  }

  if (start_unsorted === null) return null

  // desc look for bump
  for (let i=arr.length-1; i>0; i--) {
    if (arr[i] < arr[i-1]) {
      end_unsorted = i
      break
    }
  }

  let min = Infinity
  let max = -Infinity

  for (let i=start_unsorted; i<=end_unsorted; i++) {
    min = Math.min(min, arr[i])
    max = Math.max(max, arr[i])
  }

  // expand start_unsorted
  for (let i=0; i<start_unsorted; i++) {
    if (arr[i] > min) {
      start_unsorted = i
      break
    }
  }

  // expand end_unsorted
  for (let i=arr.length-1; i>end_unsorted; i--) {
    if (arr[i] < max) {
      end_unsorted = i
      break
    }
  }

  // console.log(arr.slice(start_unsorted, end_unsorted+1))

  return [start_unsorted, end_unsorted]
}
```

## 5. Sort Squared

Interview Camp Ch 1. Homework #2

<Aside pTags={[
  `Given a sorted array in non-decreasing order, return an array of squares of each number, also in non-decreasing order. For example:`,
  `[-4,-2,-1,0,3,5] -> [0,1,4,9,16,25]`,
  `How can you do it in O(n) time?`
]} />

```js
const sortSquared = arr => {
  if (!arr.length) return []

  let start = 0
  let end = arr.length - 1
  let ret = Array.from(Array(arr.length))

  let retIdx = arr.length - 1
  while (start <= end) {
    let startVal = Math.abs(arr[start])
    let endVal = Math.abs(arr[end])

    if (startVal > endVal) {
      ret[retIdx] = startVal ** 2
      start++
    } else {
      ret[retIdx] = endVal ** 2
      end--
    }

    retIdx--
  }

  return ret
}

```

## 4. Reverse sentence

Interview Camp Ch 1. Homework #1

<Aside pTags={
  [
    `Given a sentence, reverse the words of the sentence. For example, "i live in a house" becomes "house a in live i".`,
  ]} />

```js
const reverseSentence = sentence => {
  let res = ''
  let currWordEnd = sentence.length - 1

  for (let i=sentence.length-1; i >= 0; i--) {
    if (sentence[i] === ' ') {
      res += sentence.slice(i+1, currWordEnd+1) + ' '
      currWordEnd = i-1
    }
  }

  res += sentence.slice(0, currWordEnd+1)

  return res
}
```

## 3. Roman to Integer

[Leetcode](https://leetcode.com/problems/roman-to-integer/)

```js
const romanToInt = function(s) {
  const NUM_BY_CHAR = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000,
  }
  
  const SUBTRACTABLE_NUM = new Set(['I', 'X', 'C'])

  let ret = 0
  let lastNum = null
  for (let i = s.length-1 ; i >= 0; i--) {
    const char = s[i];
    let num = NUM_BY_CHAR[char]

    if (SUBTRACTABLE_NUM.has(char) && lastNum && num < lastNum) {
      ret -= num;
    } else {
      ret += num;
    }
    lastNum = num;
  }

  return ret;
};
```

## 2. isPalindrome

[Leetcode](https://leetcode.com/problems/palindrome-number/)

```js
const isPalindrome = function(x) {
  let stack = [];
  
  let val = x.toString()

  // middle left/right idx
  let left, right;

  const mid = Math.floor(val.length / 2);
  if (val.length % 2 == 1) {
    left = mid - 1
    right = mid + 1
  } else {
    left = mid - 1
    right = mid
  }

  for (let i=0; i < val.length; i++) {
    const char = val[i]
    if (i <= left) {
      stack.push(char)
    }
    if (i >= right) {
      const popped = stack.pop()
      if (popped !== char) {
        return false
      }
    }
  }

  return true
};
```
## 1. twoSum

[Leetcode](https://leetcode.com/problems/two-sum/)

```js
const twoSum = function(nums, target) {
    let temp = new Map()
    
    for (let idx = 0; idx < nums.length; idx++) {
        const num = nums[idx]
        const diff = target-num
        if (temp.has(diff)) {
            return [temp.get(diff), idx]
        }
        
        temp.set(num, idx);
    }

    return []
};
```

export default ({ children }) => <BlogMarkdown meta={meta}>{children}</BlogMarkdown>